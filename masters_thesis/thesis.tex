\documentclass[12pt, twoside]{fithesis2}

% ===== PACKAGES =====
% language settings
\usepackage[english]{babel}
% enabling new fonts support (nicer)
\usepackage{lmodern}
% setting input encoding
\usepackage[utf8]{inputenc}
% setting output encoding
\usepackage[T1]{fontenc}
% fithesis2 requires csquotes
\usepackage{csquotes}
% set page margins
\usepackage[top=3.0cm, bottom=3.5cm, left=2.9cm, right=1.9cm]{geometry}
% package to make bullet list nicer
\usepackage{enumitem}
% math symbols and environments
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
% packages for complex tablestj
\usepackage{tabularx}
% package for defining new floating environments
\usepackage{float}
\usepackage[labelfont=]{caption}
% package for drawing
\usepackage{tikz}
\usetikzlibrary{shapes,positioning,fit,plotmarks}
% code listings
\usepackage{listings}
% code highlighting
\usepackage[chapter]{minted}

\usepackage{pdfpages}
\usepackage{afterpage}
\usepackage{dirtree}

% space between paragraphs [smaller space between paragraphs]
\setlength{\parskip}{0.6em plus0.2em minus0.2em}

% bibliography management
\usepackage[
  backend=biber, % use biber
  bibstyle=ieee-alphabetic, %IEEE with alphabetic citations
  citestyle=alphabetic, % citation style
  %citestyle=numeric, % citation style
  url=true, % display urls in bibliography
  hyperref=auto, % detect hyperref and create links
]{biblatex}
\addbibresource{thesis.bib}

% break long urls
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}

% setting custom colors for links
\usepackage{xcolor}
\definecolor{theme-red}{rgb}{0.62,0.01,0.05}
\definecolor{dark-red}{rgb}{0.6,0.15,0.15}
\definecolor{dark-green}{rgb}{0.15,0.4,0.15}
\definecolor{medium-blue}{rgb}{0,0,0.5}
\definecolor{light-gray}{rgb}{0.93,0.93,0.93}

\def\chapterautorefname{Chapter}

% generating hyperlinks in document
\usepackage{url}
\usepackage{xpatch}
\usepackage[
    plainpages=false, % get the page numbering correctly
    pdfpagelabels, % write arabic labels to all pages
    unicode, % allow unicode characters in links
    colorlinks=true, % use colored links instead of boxed
    linkcolor={theme-red},
    citecolor={theme-red},
    urlcolor={theme-red}
]{hyperref}

\providecommand*{\listingautorefname}{listing}

\newcommand\blankpage{%
    \null
    \thispagestyle{empty}%
    \addtocounter{page}{-1}%
    \newpage}

% ===== FI THESIS SETTINGS =====
\thesistitle{Extracting Parts of Programs into Separate Binaries}
\thesissubtitle{Master's thesis}
\thesisstudent{Tomáš Mészaroš}
\thesiswoman{false}
\thesisfaculty{fi}
\thesisyear{2018}
\thesisadvisor{Mgr. Marek Grác, Ph.D.}
\thesislang{en}

% ===== LATEX DOCUMENT SETTINGS =====
% only put chapters and sections into the TOC
\setcounter{tocdepth}{2}

% renew command for shorter and nicer underscore
\renewcommand{\_}{\leavevmode \kern0.07em\vbox{\hrule width0.4em}}

% ===== COMMANDS =====
% define square symbol
\newcommand{\squarebullet}{\textcolor{black}{\raisebox{0.15em}{\rule{4pt}{4pt}}}}
\newcommand{\emptysquarebullet}{\textcolor{black}{\raisebox{0.10em}{\tiny$\square$}}}

\newenvironment{myItemize}{
  \begin{itemize}[
    leftmargin=2em,
    rightmargin=1em,
    itemsep=\parskip,
    parsep=0em,
    topsep=0em,
    partopsep=0em
]
  \renewcommand{\labelitemi}{\squarebullet}
  \renewcommand{\labelitemii}{\textbullet}
}{
  \end{itemize}
}

\newenvironment{myEnumerate}{
  \begin{enumerate}[
    leftmargin=2em,
    rightmargin=1em,
    itemsep=\parskip,
    parsep=0em,
    topsep=0em,
    partopsep=0em
]
}{
  \end{enumerate}
}

% define new environment for code
\lstnewenvironment{code}{
  \lstset{
  frame=lines,
  rulecolor=\color{black},
  basicstyle=\ttfamily,
  columns=fullflexible,
  showspaces=false,
  showstringspaces=false,
  escapeinside={<*}{*>},
  belowskip=0.2em
  }}{}


% ===== BEGIN DOCUMENT =====
\begin{document}

\FrontMatter
\ThesisTitlePage

% zadanie a prehlasenie
% TODO: Comment this for the electronic version!
%\includepdf[pages=-]{blank.pdf}
%\includepdf[pages=-]{zadanie.pdf}
%\includepdf[pages=-]{blank.pdf}
%\includepdf[pages=-]{prehlasenie.pdf}

\begin{ThesisDeclaration}
    \DeclarationText
    \AdvisorName
\end{ThesisDeclaration}

\begin{ThesisThanks}
Dedicated to those who are brave enough to read this stuff.

You are heroes!

\bigskip
\begin{figure}[ht]
    \includegraphics[width=320px]{images/one_does_not_simply.jpg}
\end{figure}

\end{ThesisThanks}

\begin{ThesisAbstract}
    abstract TBA
\end{ThesisAbstract}

\begin{ThesisKeyWords}
    keyword, keyword, keyword, keyword, keyword, keyword
\end{ThesisKeyWords}


\MainMatter
\tableofcontents



% === CHAPTER ==================================================================
\chapter{Introduction: TODO}
\label{chap:intro}

User wants to know the value of some variable in the program. He/she can run
debugger of choice, set breakpoint at the selected variable location and let
debugger execute input program step by step until it reaches the selected
variable. Finally, debugger steps on the targeted variable and thus can extract
its value and provide it back to the user.

The procedure described above is usually part of the standard standard approach
when user want to get value of some selected variable during the program
execution. Unfortunately, this approach is cumbersome in case when user want to
execute above procedure many times. Procedure consists of many manual steps
which is time consuming to perform. Ideally, there could be script that takes
line of code (or variable name) as an input and produces output with the value
of the selected target

Normally, this method would require to use debugger with the scripting support
and write scripts that would instruct debugger what exactly to do, basically
replicating the manual approach.

Instead of scripting debugger to do the extraction, we could write tool that
would accept the same user input as the approach above (line of code/variable
name), run analysis on where the execution flow in the program would occur to
get to the target instruction and transplant subset of the input program into
separate binary.

This way, user will have separate, executable that upon running would produce
value of the targeted instruction, without having to manually step thought or
script debugger.

This thesis aims to devise method and implement this method in a tool for
statically transplanting a subset of a C program. Using the devised method, the
selected program subset should be extracted from the original program provided
by the user and synthesized as an independent, executable binary.

Proposed solution should be implemented in a tool having appropriate form,
either as a standalone application or an LLVM plugin. It should easily accept
user to provide their own input programs.

Finally, tool should be used to test at least two real-world open-source C
programs in order to find where the room for improvements is and what could be
improved in the future.


% summary of the thesis

The following sections of this thesis are structured as follows.
In the \autoref{chap:llvm} we will briefly introduce the LLVM compiler
infrastructure.  Explain what makes it so popular and why we picked this tool
for our implementation.
The following \autoref{chap:design}, we will introduce method that is the basis
of this thesis aim.
We will devote \autoref{chap:implementation} for explaining specific details
and intricacies of implementation.
Experiments and their results will be discussed in the chapter
\autoref{chap:experiments}. Finally \autoref{chap:conclusions} summarizes the
results of this thesis and describes possible further research and development
opportunities.


\chapter{The LLVM Compiler Infrastructure: TODO}
\label{chap:llvm}

"The LLVM (FOOTNOTE:The name "LLVM" itself is not an acronym; it is the full
name of the project.) Project is a collection of modular and reusable compiler
and toolchain technologies." \cite{llvm}

"an umbrella project that hosts and develops a set of close-knit low-level
toolchain components (e.g., assemblers, compilers, debuggers, etc.), which are
designed to be compatible with existing tools typically used on Unix systems"

"the main thing that sets LLVM apart from other compilers is its internal
architecture." [6] Primary subprojects:

LLVM core clang ...  Strengths: "A major strength of LLVM is its versatility,
flexibility, and reusability"

\section{Intermediate Representation}
\label{sec:llvm-ir}

% subsection
Introduction
- IR AKA LLVM assembly language AKA LLVM

- "LLVM is a Static Single Assignment (SSA) based representation that provides
type safety, low-level operations, flexibility, and the capability of
representing ‘all’ high-level languages cleanly. It is the common code
representation used throughout all phases of the LLVM compilation strategy."

- Aims:
 - "The LLVM representation aims to be light-weight and low-level while being
 expressive, typed, and extensible at the same time."

- Representations of IR:
 - as an in-memory compiler IR
 - as an on-disk bitcode representation (suitable for fast loading by a
 Just-In-Time compiler)
 - as a human readable assembly language representation

% subsection
Example of the IR

We have the following C function add

\begin{minted}[ framesep=2mm,
                autogobble,
                frame=lines]{C}
int add(int a, int b) {
    return a+b;
}
\end{minted}

When using clang compiler with -emit-llvm flag, we get the following representation in IR:

\begin{minted}[ framesep=2mm,
                autogobble,
                frame=lines]{llvm}
define i32 @add(i32 %a, i32 %b) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  %0 = load i32, i32* %a.addr, align 4
  %1 = load i32, i32* %b.addr, align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
\end{minted}

% subsection
High Level Structure

- Module structure:
 - functions
 - global variables
 - symbol table entries

- using LLVM linker for module combination
 - we will use this in practice

- Functions:
 - "A function definition contains a list of basic blocks, forming the CFG
 (Control Flow Graph) for the function."
 - PHI nodes


\section{Optimisations}
\label{sec:llvm-opt}

LLVM uses the concept of Passes for the optimisations. Concrete optimisations
are implemented as Passes that work with some portion of program code (e.g.
Module, Function, Loop, etc.) to collect or transform this portion of the code.
\cite{llvm-passes}

There are the following types of passes:

Analysis passes
- Analysis passes collect information from the IR and feed it into the other
passes. They can be also used for the debugging purposes, for example pass that
counts number of functions in the module.

Examples:

- basiccg: Basic CallGraph Construction
- dot-callgraph: Print Call Graph to “dot” file
- instcount: Counts the various types of Instructions

Transform passes
- Transform passes change the program in some way. They can use some analysis
pass that has been ran before and produced some information.

Examples:

- dce: Dead Code Elimination
- loop-deletion: Delete dead loops
- loop-unroll: Unroll loops

Utility passes
- Utility passes do not fit into analysis passes or transform passes categories.

Examples:

- verify: Module Verifier
- view-cfg: View CFG of function
- instnamer: Assign names to anonymous instructions

\section{Clang}
\label{sec:llvm-clang}

"The Clang project provides a language front-end and tooling infrastructure for
languages in the C language family"

Features and Goals (some overview of clang):
- End-User Features
- Utility and Applications
- Internal Design and Implementation

AST
- what is AST
- AST in clang
- Differences between clang AST and other compilers ASTs
- We will not use clangs AST, we will work directly with IR, it better suits
this project


% === CHAPTER: Design of the Method ============================================
\chapter{Extracting Program Subsets: WIP}
\label{chap:design}

\textbf{TODO: weire intro about this chapter structure.}
\\
In this chapter, we introduce the method for extracting parts of programs
from the provided user input.

We start with the method overview in the \autoref{sec:method_overview} where we
define what is the user input and briefly outline the method itself, what it
does and what are the steps for achieving the final result.

We follow with the example of the method from the user perspective in the
\autoref{sec:method_example}.

After example, we present in detail each major step that is followed.
Starting with computing data dependencies graph
(\autoref{sec:design-dep}).
Following with the procedure for finding connected components in the computed
data dependencies graph (\autoref{sec:design-components}).
Next follows introduction of the call graph (\autoref{sec:design-callgraph}) and
subsequently procedure for finding path from source to target in it
(\autoref{sec:design-path}).
The chapter ends with the section describing methods on eliminating dead
components and functions from the code (\autoref{sec:design-removing}).


% ===== SECTION: Method Overview
\section{Method Overview}
\label{sec:method_overview}

% method input definition
Mandatory \textbf{input} for the method is a touple with the following
definition:

$$
input \equiv (code, target)
$$

where:
\begin{myItemize}
\item \textbf{code} is a C program source code compiled into the llvm bytecode.
\item \textbf{target} is an integer value representing line of code from the
C program source code.
\end{myItemize}

We also define \textbf{source} as an entry to the C program
(\mintinline{text}{main} function).

\bigskip
% what the method does

The method determines what parts of the \emph{input} to extract according to
the \emph{source} and \emph{target}.
Procedure subsequently calculates possible execution path up to the
\emph{target} and extracts this execution path into the separate, functioning
executable.

Barring implementation specific details (which are discussed in the
\autoref{chap:implementation}), the method can be summarized by the following
five steps:

\begin{myEnumerate}
\item Compute data dependencies between instructions.
\item Find connected components in the computed data dependencies inside
every function.
\item Construct call graph, mapping between connected components and functions
that are being called from these components.
\item Find path from source to target in the call graph.
\item Eliminate dead components and functions that do not depend on the path.
\end{myEnumerate}

\bigskip
% what is the result of the method
Upon completion of the steps mentioned above, the llvm bytecode is produced as
an \emph{output}.
We can define \textbf{output} as the extracted part of the original program
according to the \emph{source} and \emph{target} while keeping the consistency
of the code intact.
By \textbf{consistency}, we mean that the \emph{output} code is in a such state
that it was possible to be compiled.
\emph{Output} is expected to be runnable the same way as
the original.
\textbf{**TODO? explain more here or in another chapter what it means for IR to be
compiled without problems?**}

% === SECTION: Method Example
\section{Example}
\label{sec:method_example}

User provided us with the \emph{input} in the form of the following
C program source code that is stored in the file \mintinline{text}{example.c}:

\begin{minted}[label=example.c,frame=lines,framesep=10pt,linenos]{C}
int foo(int n) {
    int x = n + 10;
    return x;
}

int bar(void) {
    int y = 42;
    return y;
}

int main(void) {
    int some_int = 10;
    int foo_result = foo(some_int);
    int bar_result = bar();
    return 0;
}
\end{minted}

Since our method does not work directly with the C source code but instead
works with the LLVM Intermediate Representation (IR), lets use clang and emit
IR from the presented C source code in order to demonstrate the procedure more
clearly:
\footnote {
Flag \mintinline{text}{-S} tells clang to only run preprocess and
compilation steps, while \mintinline{text}{-emit-llvm} makes sure to use the LLVM
representation for assembler and object files. For detailed description of
various clang flags, visit
\url{https://clang.llvm.org/docs/ClangCommandLineReference.html}.
}

\begin{minted}[frame=lines,framesep=10pt]{bash}
  clang -S -emit-llvm example.c -o example.s
\end{minted}

Emitted LLVM IR is stored in the file \mintinline{text}{example.s} and
has the following structure:\footnote{
Strictly speaking, this is not exactly the IR code that would be emitted by the
clang. We have stripped it out of the module info and comments to make it more
readable. To see the unmodified \mintinline{text}{example.s}, please go to the
\autoref{appendix:example}.
}

\begin{minted}[label=example.s,frame=lines,framesep=10pt,linenos]{llvm}
define i32 @foo(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %x = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %add = add nsw i32 %0, 10
  store i32 %add, i32* %x, align 4
  %1 = load i32, i32* %x, align 4
  ret i32 %1
}

define i32 @bar() #0 {
entry:
  %y = alloca i32, align 4
  store i32 42, i32* %y, align 4
  %0 = load i32, i32* %y, align 4
  ret i32 %0
}

define i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %some_int = alloca i32, align 4
  %foo_result = alloca i32, align 4
  %bar_result = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 10, i32* %some_int, align 4
  %0 = load i32, i32* %some_int, align 4
  %call = call i32 @foo(i32 %0)
  store i32 %call, i32* %foo_result, align 4
  %call1 = call i32 @bar()
  store i32 %call1, i32* %bar_result, align 4
  ret i32 0
}
\end{minted}

% next point
User also provided the line number \textbf{7} from the
\mintinline{text}{example.c} as the target, which corresponds to the line
\textbf{16} from the \mintinline{text}{example.s}. Source is the main function.

Procedure for finding mapping between C code referenced by the user input and
its analogous IR instruction is implementation detail and is be described
in the \autoref{chap:implementation}.

\bigskip

% next point
When we apply the method on the contents of the
\mintinline{text}{example.s} with respect to the source and target,
we get the result stored in the file
\mintinline{text}{example_extracted.s} with the following code:

\begin{minted}[label=example\_extracted.s,frame=lines,framesep=10pt]{llvm}
define i32 @bar() #0 {
entry:
  %y = alloca i32, align 4
  store i32 42, i32* %y, align 4
  ret i32 %0
}

define i32 @main() #0 {
entry:
  %bar_result = alloca i32, align 4
  %call1 = call i32 @bar()
  store i32 %call1, i32* %bar_result, align 4
  ret i32 0
}
\end{minted}

As we can see from the \mintinline{text}{example.c}, execution path from
the program entry in the \mintinline{text}{main} function (which we will
call \textbf{source}) to the \textbf{target} does not include function
\mintinline{text}{foo} and its associated instructions, they can be removed.
We are left only with function \mintinline{text}{bar} which contains target,
and necessary instructions in the function \mintinline{text}{main} along with
the \mintinline{text}{main} itself.
\\
\\
We can now take \mintinline{text}{example_extracted.s} and recompile it back
into the functioning executable.\footnote{
More about recompilation in the \autoref{chap:implementation}.
}


% === SECTION ===
\section{Computing Data Dependencies}
\label{sec:design-dep}

% motivation
In order to identify what parts of the IR we can afford to remove, it is
imperative to compute dependencies between instructions.
When removing instructions, we need to preserve consistency of the remaining
code so that it can be later compiled into a functional executable.
To ensure this, we first compute dependencies among instructions.

\bigskip

% definitions
We recognize two types of dependencies between IR instructions: control and data
dependencies.
The following terminology and procedures for computing dependencies that we use
are due to the Marek Chalupa master's thesis \textit{Slicing of LLVM Bitcode}
\cite{dg}.

\begin{myItemize}
\item ``\textbf{Control dependence} explicitly states what nodes are
controlled by which predicate.``
\item ``A \textbf{data dependence} edge is between nodes n and
m iff n defines a variable that m uses and there is no intervening definition
of that variable on some path between n and m. In other words, the definitions
from n reach uses in m.``
\end{myItemize}

\bigskip

% method
The crucial information comes from data dependencies. We need to make sure that
the IR integrity will remain intact after we are done with removing IR
instructions.

The following example demonstrates data dependencies for the
previously presented \mintinline{text}{example.c} source code.
Taking closer look specifically at the function \mintinline{text}{main}:

\begin{minted}[frame=lines,framesep=10pt]{llvm}
define i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %some_int = alloca i32, align 4
  %foo_result = alloca i32, align 4
  %bar_result = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 10, i32* %some_int, align 4
  %0 = load i32, i32* %some_int, align 4
  %call = call i32 @foo(i32 %0)
  store i32 %call, i32* %foo_result, align 4
  %call1 = call i32 @bar()
  store i32 %call1, i32* %bar_result, align 4
  ret i32 0
}
\end{minted}

Taking \mintinline{text}{main} code, we can construct graph G where V is set
of vertices (in our case vertex is instruction) and E is set of edges (in our
case, edge between vertices V1 and V2 represents data dependency between
instruction V1 and V2).
In order to compute data dependencies, we use \mintinline{text}{dg} library.
\cite{dg}
\footnote{
For more info please visit \url{https://github.com/mchalupa/dg} \cite{dg}.
We will take a closer look at \mintinline{text}{dg} in the
\autoref{chap:implementation}.
}

Computed \textbf{data dependency graph} for instructions from the function
\mintinline{text}{main} is presented in the \autoref{fig:data_deps_graph}.
This graph is stored and used in the next step of the method for finding
connected components (\autoref{sec:design-components}).

\begin{figure}[ht]
    \centering
    \includegraphics[]{images/main_dependencies.pdf}
    \caption{Data dependencies graph of the \mintinline{text}{main} function instructions.}
    \label{fig:data_deps_graph}
\end{figure}

Taking a closer look at the instruction:
\mintinline{llvm}{%some_int = alloca i32, align 4}.
We see that the following instructions have data dependency on the
\mintinline{llvm}{%some_int}

\begin{minted}[frame=lines,framesep=10pt, escapeinside=||]{llvm}
  store i32 10, i32* %some_int, align 4
  %0 = load i32, i32* %some_int, align 4
\end{minted}

It is apparent that both instructions need \mintinline{llvm}{%some_int} for
their operand. If we removed
\mintinline{llvm}{%some_int = alloca i32, align 4}
without taking into consideration that there are two
instructions that depend on it, we would get into inconsistent state and two
dependent instructions would contain undefined values as their operand.\footnote{
More about undefined values at
\url{https://llvm.org/docs/LangRef.html\#undefined-values},
\url{https://llvm.org/docs/FAQ.html\#what-is-this-undef-thing-that-shows-up-in-my-code},
\url{https://llvm.org/doxygen/classllvm_1_1UndefValue.html}
}
This would lead into unsuccessful recompilation of the modified code back into
the executable.

% === SECTION ===
\section{Finding Connected Components}
\label{sec:design-components}

% motivation
Having shown in the previous section what are inter-instruction data
dependencies and how important they are in relation to the code consistency.
However, they do not fully solve our problem of knowing when it is safe to
remove instruction.
Data dependencies between only two instructions do not reveal the whole picture.
Since we have computed and stored graph of data dependencies, let us propose the
idea of computing connected components of this graph.

\bigskip

% definitions
We define \textbf{connected component} as an isolated subgraph, where
each pair of vertices is connected by some path.

We use \textbf{data dependency graph} computed in the section
\autoref{sec:design-dep} to find its connected components by using the following
algorithm:

\begin{minted}[label=finding components,escapeinside=||,frame=lines,framesep=10pt]{text}
0. Let G = data dependency graph
1. Run |Breadth-first search \cite{clrs}| on G to visit each instruction
2. IF instruction not in any component:
      create new component and put instruction inside
   ELSE:
      go to next instruction
\end{minted}

Running the above mentioned algorithm on the \textbf{data dependency graph}
produces connected components for each function in the input.
As an example, we present components for the \mintinline{text}{main} function
in the \autoref{fig:connected_components_graph} (for the clarity, each component
has its own color).

\begin{figure}[ht]
    \centering
    \includegraphics[]{images/main_components.pdf}
    \caption{Connected components of the data dependencies graph
    for the \mintinline{text}{main} function instructions. Individual components
    are differentiated by the color.}
    \label{fig:connected_components_graph}
\end{figure}

\bigskip

% why having components is good
Having instructions within each function separated into connected components
comes useful especially because we can answer the question if some particular
instruction is in data dependency relationship with multiple other instructions
(instructions that form a data dependency path, etc.).

% === SECTION ===
\section{Computing Call Graph}
\label{sec:design-callgraph}

%motivation

In respect to the program execution flow, user provided the target and we know
the source.
In order to proceed further, it is needed to compute possible paths from
source to target that could be used by the execution of the program.
Computing and walking the call graph of the program can produce for us this
piece of information.

% definition

A \textbf{call graph}\footnote{
More technically, \emph{call multigraph} \cite{data_flow}.}
is a control flow graph that represents relationship
between program procedures in respect to control flow.\cite{data_flow}
Having call graph $G = \{V, E\}$, set of vertices $V$ typically represents
functions and set of edges $E$ represents transfer of control flow from one
function to another.

In our context, call graph represents relationship between individual
connected components (computed in the \autoref{sec:design-components})
and functions that are being called from these components by one of its
instructions. In other words, our call graph is a set of mappings from
components to the function (or functions).


% example

We construct the call graph using the following algorithm:

\begin{minted}[label=computing call graph,escapeinside=||,frame=lines,framesep=10pt]{text}
0. Let FS = set of functions in the code
1. Let CS(f) = set of components inside function f
2. FOR EACH function F in the set FS:
      FOR EACH component C in the set CS(F):
         FOR EACH instruction I in the component C:
            IF instruction I is a call instruction to some function X:
                store information X gets called from the C
\end{minted}

Running the presented algorithm on the \textbf{data dependence graph}
of the \mintinline{text}{main} function that we computed earlier
(\autoref{fig:connected_components_graph}) produce call graph structure
shown in the \autoref{fig:call_graph}. We know that in the context of the
\mintinline{text}{main} function, there are four distinct components.
We can see from the computed call graph, that
\mintinline{llvm}{i32 @foo(i32 %n)} is being called from the
\emph{yellow} component, and
\mintinline{llvm}{i32 @bar()} is being called from the \emph{red} component.

\begin{figure}[ht]
    \centering
    \includegraphics[]{images/main_callgraph.pdf}
    \caption{Call graph computed from the connected components
    as shown in the \autoref{fig:connected_components_graph}.}
    \label{fig:call_graph}
\end{figure}


% === SECTION ==================================================================
\section{Finding Path from Source to Target}
\label{sec:design-path}

% motivation

Having call graph represented in the structure shown in the
\autoref{fig:call_graph} is beneficial for finding program execution flow path
between specific components within the program in relation to their
dependencies. We can find path from source to target and know which components
this path contains.

% definitions

\emph{''A \textbf{path} is a simple graph whose vertices can be arranged in a linear sequence in
such a way that two vertices are adjacent if they are consecutive in the sequence,
and are nonadjacent otherwise.''}\cite{graph_theory} In our case, linear
sequence of vertices consists of components computed in the
\autoref{sec:design-components}.

% method

The reason why we constructed call graph in the previous chapter is now apparent.
We want to find a path from source to the target and in doing so, know which
connected components are part of this path or not.
Potentially, there may exist infinite number of such paths. From
the optimization standpoint, it would be fitting to find all (or at least as
many as we can) paths and pick some path according to selected optimization
criteria (shortest path, path with smallest connected components, etc.).
However, for our purposes, it will be sufficient to find any path, because
our method does not try to optimize final code in respect to size, speed, etc.

We will use the following algorithm in order to find a path from source to target
in the call graph:

\begin{minted}[label=finding path,escapeinside=||,frame=lines,framesep=10pt]{text}
0. Let G = call graph
1. Run Breadth-first search on G to find path from source to target
\end{minted}

\begin{figure}[ht]
    \centering
    \includegraphics[]{images/main_path.pdf}
    \caption{Path from \textbf{source} to \textbf{target} computed on the
    \autoref{fig:call_graph}. Components in the path are \emph{blue}.
    }
    \label{fig:path}
\end{figure}

Given the source and target, we can see from the \autoref{fig:path} that path
only contains two components, one from \mintinline{text}{main} function and
another from \mintinline{text}{bar}. These two components are going to be the
core of the final, extracted program.

% === SECTION ==================================================================
\section{Eliminating Dead Components and Functions}
\label{sec:design-removing}

\textbf{TODO}

% motivation
Having successfully found path, we can proceed to the final phase.
We need to eliminate all components and functions that do not impact the path.

% method
If we take a look at the \autoref{fig:removing_prepare}, we can see that
components marked as \emph{red} do not impact the path at all and therefore, we
can mark them for elimination.

The \emph{yellow} component with the single instruction stands out.
We will not remove this component because it contains
terminator instruction \mintinline{llvm}{ret i32 0}.\footnote{
\url{https://llvm.org/doxygen/classllvm_1_1TerminatorInst.html}
More about terminators and why they need special treatment in the
\autoref{chap:implementation}.
}

\begin{figure}[ht]
    \centering
    \includegraphics[]{images/main_removing_prepare.pdf}
    \caption{
    Components marked for removal are marked \emph{red}. \emph{Yellow} component
    is not marked for removal, because it contains terminator.
    }
    \label{fig:removing_prepare}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[]{images/main_removing_done.pdf}
    \caption{Final state after removing dead components and functions.
    }
    \label{fig:removing_done}
\end{figure}

When we are done going over every component and collecting selected ones for
elimination, we can proceed to actually eliminate them (remove them from the
\mintinline{text}{example.s}).

After we are done with components, we can move to the functions. It may happen
that there will be function not impacting path. For example, taking function
\mintinline{llvm}{i32 @foo(i32 %n)} from the \autoref{fig:removing_prepare},
It is clearly not impacting path. It even has its one and only component marked
for elimination. In this case, we can proceed and remove function
\mintinline{llvm}{i32 @foo(i32 %n)} altogether.

Finally, finished with elimination process, we are left with the result in the
form of the \autoref{fig:removing_done}.

\textbf{TODO: this below should be move to the \autoref{sec:design-removing}}

Lets take \mintinline{llvm}{%call = call i32 @foo(i32 %0)} as an example.
Having computed connected components, we can see that this instruction
belongs to the \emph{yellow} connected component.

Now, if we were not interested in this particular instruction and wanted to
remove it, we now know that we need to take care a closer look at the whole
component and not only on one particular instruction.

\textbf{TODO: Explicitly define when we are removing functions and what exactly are we doing}

It would not be sufficient to only remove
\mintinline{llvm}{%call = call i32 @foo(i32 %0)} because there are other
instructions within the same component, which means that other members of the
\emph{yellow} component are in dependency relationship with each other.

The good thing is that if we were to remove some unwanted instruction,
for instance \mintinline{llvm}{%retval = alloca i32, align 4} from the \emph{blue} component
we now have the information and know that we should remove also
\mintinline{llvm}{store i32 0, i32* %retval, align 4}. This way, we will not
leave any instructions stranded and with missing dependencies.
As we mentioned earlier, this will ensure that the IR is in the consistent state
and we will be able to recompile the modified IR back into the functioning
executable.
% === CHAPTER: Implementation ==================================================
\chapter{Implementation: TODO}
\label{chap:implementation}

%section
\section{APEX}

\subsection{what is APEX}

\subsection{two components of apex}
\begin{myEnumerate}
\item launcher
\item APEXPass
\end{myEnumerate}

% section
\section{Launcher}

\subsection{compiling input to bytecode with dbg symbols}

\subsection{running basic opts}

\subsection{linking input with apexlib}

\subsection{running apexpass}

\subsection{exporting call graph, dependency graph, disassembly bc}

\subsection{running final binaries}

% section
\section{APEXPass}

\subsection{User Inpur Parsing, Mapping C code to IR}

\subsection{Compute data dependencies between instructions.}
- running dg, init apexdg

\subsection{Find connected components in the apexdg.}

\subsection{Construct call graph, mapping between connected components and functions
that are being called from these components.}

\subsection{Find path from source to target in the call graph.}

\subsection{Eliminate dead components and functions that do not depend on the path.}
The simplest and seemingly correct way would be to remove every connected
component that is not part of the path that we calculated in the earlier
chapter.

This approach would unfortunately produce inconsistent IR. It not enough to
remove only components in the path. We need to include every other component
that is dependent on any other component that is already part of the path.

Checking if we have any branching dependent on the @path
\begin{myEnumerate}
\item investigating block, collecting basic blocks
\item block has no instruction in "if.*" basic block
\item block has some instruction in "if.*" basic block
\item Find branch instruction that services this BB and add block associated with this branch instruction to the @path.
\end{myEnumerate}

Computing what dependency blocks we want to keep
\begin{myEnumerate}
\item marking every block from @path as to keep
\item Mark as visited to make sure we do not process this block in BFS.
\item setting up initial queue for BFS search
\item Go over @path and figure out if there are any calls outside the @path. If there
are, put those called blocks for investigation into the @queue.
\item running BFS
\item Run BFS from queue and add everything for keeping that is not visited.
\item Collecting everything that we do not want to keep
\item We store blocks and functions that we want to remove into sets.
\end{myEnumerate}

Removing unwanted blocks
\begin{myEnumerate}
\item Remove instructions that we stored earier. Watch out for terminators (do not
remove them).
\item Do not erase instruction that is inside target instructions (We need those
instructions intact.)
\end{myEnumerate}

\subsection{Injecting extraction and exit}

\subsection{Recompilation, stripping debug symbols}

%section
\section{Recompilation back to the executable}

% === CHAPTER: Experiments =====================================================
\chapter{Experiments: TODO}
\label{chap:experiments}


% === CHAPTER: Conclusions =====================================================
\chapter{Conclusions: TODO}
\label{chap:conclusions}

% === SECTION ===
\section{Summary of the Results}
\label{sec:conclusions-summary}

% focus on our specific contributions
% focus on the wider view, what this thesis brought to the world

% === SECTION ===
\section{Further Research and Development}
\label{sec:conclusions-next}

% what could be improved theoretically? (e.g. multiple paths, etc.)
% what could be improved technically? (e.g. better json dump)


% === BIBLIOGRAPHY =============================================================
\appendix

% print complete bibliography
\printbibliography

% === CHAPTER ==================================================================
\chapter{Archive structure}
\label{appendix:archive}

Content of the attached archive:

TBA TBA TBA

% === REMOVE THIS BEFORE PRINTING ==============================================
\chapter{Outline}

Extracting Parts of Programs into Separate Binaries

\begin{myEnumerate}
\item Get acquainted with means of the compilation of C programs using the LLVM
compiler infrastructure - clang, LLVM Internal Representation, AST, LLVM
optimizations.
\item Propose a solution to statically transplant a subset of a C program. This
subset should be extracted from the original program and synthesized as an
independent binary.
\item Design and implement the proposed solution in a tool having an
appropriate form (a standalone application or an LLVM plugin).
\item Test the implemented tool on at least 2 real-world open-source C
programs.
\end{myEnumerate}

\noindent\rule{\textwidth}{1pt}

\begin{myItemize}

\item Introdution
    \begin{myItemize}
    \item Give introduction to wider context
    \item Clearly explain aim of the thesis
    \item Give outline of the following chapters
    \end{myItemize}

\item The LLVM Compiler Infrastructure
    \begin{myItemize}
    \item IR
    \item Optimizations
    \item clang
    \end{myItemize}

\item Extracting Program Subsets
    \begin{myItemize}
    \item Intro
    \item
    \item Computing Data Dependencies
    \item Finding Connected Components
    \item Constructing Call Graph
    \item Finding Path
    \item Removing Unnecessary Parts
    \end{myItemize}

\item Implementation
    \begin{myItemize}
    \item APEX
    \item APEXPass
    \item Input Source Code
    \item Parsing User Input (Locating Target Instructions)
    \item Computing Dependencies using dg
    \item Extracting Target Data (Injecting Exit and Extraction)
        \begin{myItemize}
        \item Stripping debug symbols
        \end{myItemize}
    \end{myItemize}

\item Experiments
    \begin{myItemize}
    \item Experiment 1
    \item Experiment 2
    \item Experiment 3
    \end{myItemize}

\item Conclusion
    \begin{myItemize}
    \item Show our contribution to the problem
    \item Show wider image in context to this thesis
    \end{myItemize}

\end{myItemize}



% === CHAPTER ==================================================================
\chapter{\mintinline{text}{example.s}}
\label{appendix:example}

\begin{minted}[frame=lines, framesep=10pt, breaklines,linenos]{llvm}
; ModuleID = 'example.c'
source_filename = "example.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; Function Attrs: noinline nounwind optnone uwtable
define i32 @foo(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %x = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4
  %add = add nsw i32 %0, 10
  store i32 %add, i32* %x, align 4
  %1 = load i32, i32* %x, align 4
  ret i32 %1
}

; Function Attrs: noinline nounwind optnone uwtable
define i32 @bar() #0 {
entry:
  %y = alloca i32, align 4
  store i32 42, i32* %y, align 4
  %0 = load i32, i32* %y, align 4
  ret i32 %0
}

; Function Attrs: noinline nounwind optnone uwtable
define i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %some_int = alloca i32, align 4
  %foo_result = alloca i32, align 4
  %bar_result = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 10, i32* %some_int, align 4
  %0 = load i32, i32* %some_int, align 4
  %call = call i32 @foo(i32 %0)
  store i32 %call, i32* %foo_result, align 4
  %call1 = call i32 @bar()
  store i32 %call1, i32* %bar_result, align 4
  ret i32 0
}

attributes #0 = { noinline nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 5.0.1 (tags/RELEASE_500/final)"}
\end{minted}





% === END ======================================================================
\end{document}
